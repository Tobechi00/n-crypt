# N-crypt
N-crypt is a file encryption tool based on the AES (Advanced Encryption Standard) which is a variant of the Rijndael block cipher, Implemented from scratch in C++.

## How it Works:
N-crypt makes use of the AES, which is a block cypher, it operates on files, blocks at a time
and applies multiple rounds of diffusion inorder to make the block (formally known as the state) completely
unintelligible.

16bit Blocks of data arranged in Column Major Order are fed through rounds of diffusion where the number of rounds applied depends on the size of 
user inputed key chosen to encrypt the data, these keys may either be in the size of 128 bits(Aes-128),
192 bits(aes-192) or 256 bits(aes - 256), Nb: this implementation currently fully supports 128 bit(Aes-128)
encrption. Aes 128 would have 10 rounds of diffusion, Aes 192 would have 12 rounds of diffusion and Aes 256
would have 14 rounds of diffusion all implementations also feature a zero-th round making them one more than they
actually are.

## Encryption Rounds:
During each of the encryption rounds four methods of diffusion are applied to the state namely, Byte Sub,
Shift Row, Mix Column, Add Round Key.

example state:
{0x01, 0x02, 0x03, 0x04}
{0x01, 0x02, 0x03, 0x04}
{0x01, 0x02, 0x03, 0x04}
{0x01, 0x02, 0x03, 0x04}

# Byte Sub:
During the Byte Sub operation each byte of the state is split up and used to search the rijndael S-box
eg. byte one of our state is divided from 0x01 into (0, 1) and used the search the S-box in a s-box[row][column]
manner. and though the sbox may be algorithimically generated, to save compute I used a precomputed
copy of the s-box in my implementation.

# Shift Row:
During the Shift Row operation row are rotated a fixed amount of times: Row 1 is shifted 0 times,
Row 2 is shifted 1 time, Row 3 is shifted 2 times, and row 4 is shifted 3 times.

This would make our example state look like so after shifting:

```
{0x01, 0x02, 0x03, 0x04}
{0x02, 0x03, 0x04, 0x01}
{0x03, 0x04, 0x01, 0x02}
{0x04, 0x01, 0x02, 0x03}
```
# Mix Column:
During Mix Column each column of the state is matrix left multiplied with a predefined block given as:
```
{0x02, 0x03, 0x01, 0x01}
{0x01, 0x02, 0x03, 0x01}
{0x01, 0x01, 0x02, 0x03}
{0x03, 0x01, 0x01, 0x02}
```
all multiplications are done under the Aes Galois Field(GF(2^8)) which just means that multiplication
results wrap around to fit within this field.

# Add Round Key:
Using a Key Scheduler we generate round keys based on the original key inputed by the user, each
round makes use of a 16 bit block key generated by the scheduler, this means that in a 10 round encryption
round (remember round 0 so actuall 11 rounds :) ) we would have to generate 40 keys in addition to the original key for
all subsequent rounds making the total number of keys required 44 in that case.
at the end of each round these keys are XOR'd with the state and the result is carried over as the
state for the next round.

## Key Schedule:
The aes key schedule is used to generate round keys based on the original key, to do this it makes use of 
three functions:

## Rotate Word: 
which shifts the word of data (4bytes or a single column) by one equivalent to what the
shift rows function does to row two of the state but column wise instead.

## Sub Word: 
which acts similar to the sub bytes function of the aes encryptor but on a single word of 
data instead. all bytes of the word are substituted with corresponding values from the s-box.

## Apply Round Constants: 
in this round we apply round constants, which are generated by multiplying
1 with two, and all subsequent results with two, all operations take place within the finite Galois Field. these constants 
are then XOR'd with all bytes in the word.

After all rounds are completed the state is then written back to the file and the operation begins
anew on the next state read from the source (or file), to ensure alignment when the state is operated on
if data read cannot fill a 16bit state block, it is padded using a padding algorithm, for this implementation
I made use of the ```ISO/IEC 7816-4``` padding algorithm which fills the remainder of the unfilled bytes with
```1000000...```

NB: Not all operations are carried out each round, during the first round we only add in the round key,
for all middle rounds we perform the full suite of functions, and for the final round we perform
the sub bytes, shift rows and add round key functions.

# How to run:

ensure you have cmake and a c++ environment installed

clone this repo:
```
git clone Tobechi00/n-crypt
```
once you're done create a build folder in the main directory and cd into it:
```
mkdir build
cd build
```
then run:
```
cmake ..
```
once finished build the project from inside the build directory using:
```
cmake --build .
```

# n-crypt commands:
to encrypt run:
```
./ncrypt -e "file path"
```
or
```
./ncrypt --encrypt "file path"
```
and put in a 128 bit key when prompted for a ```security key```


to decrypt run:
```
./ncrypt -d "file path"
```
or
```
./ncrypt --decrypt "file path"
```
and put the same 128bit security key used to encrypt the file.


Note: This project is still being worked on and I plan to add support for aes 192 and 256 in the future ;)

I hope you enjoyed the read, and please let me know if you have any suggestions!!
